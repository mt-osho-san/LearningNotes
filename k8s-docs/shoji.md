# 概要

## Kubernets のコンポーネント

- k8s はコントロールプレーンのコンポーネントとノードというマシン郡で構成されている。

### コントロールプレーンコンポーネント

- コントロールプレーンコンポーネントはシンプルにするために、すべてのコントロールプレーンコンポーネントを同じマシンで起動し、そのマシンではユーザーコンテナは実行しない
- kube-apiserver
  - k8s api を外部に提供する k8s のコントロールプレーンのコンポーネントで、コントロールプレーンのフロントエンドになる
- etcd
  - 一貫性、高可用性を持ったキーバリューストアで、k8s のすべてのクラスター情報の保存場所として利用される
- kube-scheduler
  - コントロールプレーン上で動作するコンポーネントで、新しく作られた Pod にノードが割り当てられているか監視し、割り当てられていなかった場合にその Pod を実行するノードを選択
  - Pod のリソース要求量やハード、ソフトの制約、アフィニティ、有効期限などを考慮して行われる
- kube-controller-manager
  - 下記の複数プロセスを実行
    - ノードコントローラー：ノードがダウンした場合の通知と対応を担当
    - Job コントローラー：単発タスクを表す Job オブジェクトを監視し、そのタスクを実行して完了させるための Pod を作成 (単発タスクはどういうものがあるのか)
    - EndpointSlice コントローラ：EndpointSlice オブジェクトを作成 (Service と Pod を紐づける)
    - ServiceAccount コントローラー：新規の名前空間に対してデフォルトの ServiceAccount を作成する
- cloud-controller-manager
  - クラウド上で実行する際に利用するもので、クラウドプロバイダー固有のコントローラーのみを実行する

### ノードコンポーネント

ノードコンポーネントはすべてのノードで実行され、稼働中の Pod 管理や k8s の実行環境を提供する。

- kubelet
  - クラスター内の各ノードで実行されるエージェントで、各コンテナが Pod で実行されていることを保証する
  - PodSpec のセットを取得し、それらの PodSpec に記述されているコンテナが正常に実行されている状態を保証する
- kube-proxy
  - kube-proxy はクラスター内の各 node で動作しているネットワークプロキシ
- コンテナランタイム
  - コンテナの実行を担当するソフトウェアで、Docker、containerd, CRI-O, すべての k8s CRI をサポート

### アドオン

アドオンはクラスターレベルの機能を提供しているので、アドオンのリソースで名前空間が必要なものは kube-system 名前空間に属する

- DNS
  - クラスター DNS 以外のアドオンは必須ではないが、すべての k8s クラスターはクラスター DNS を持つべき
  - クラスター DNS は環境内の他の DNS サーバーに加えて、k8s サービスの DNS レコードを提供する DNS サーバー
- WebUI
  - クラスター内で実行されているアプリケーションについて管理、トラブルシューティングができる Web ベース UI
- コンテナリソースの監視
- クラスターレベルのロギング

---

## Kubernetes API

k8s 内のオブジェクトの状態をクエリで操作できる。
k8s のコントロールプレーンの中核は API サーバーとそれが公開する HTTP API
ユーザー、クラスターのさまざまな部分、および外部コンポーネントはすべて API サーバーを介して互いに通信する。

### 永続性

- k8s は API リソースの観点からシリアル化された状態を etcd に書き込むことで保存する

### API の変更

k8s は既存のクライアントとの互換性を破壊しない、互換性を一定期間維持して、他のプロジェクトが適応する機会を提供する

---

# k8s オブジェクトを理解する

k8s は永続的なエンティティで、下記を表現可能

- どのようなコンテナ化されたアプリケーションが稼働しているか
- それらのアプリケーションが利用可能の名リソース
- アプリケーションがどのように振る舞うかのポリシー、再起動、アップグレードなど
  k8s は意図の記録で、一度オブジェクトを作成すると、k8s は常にそのオブジェクトが存在し続けるように動く

### オブジェクトの spec(仕様)と status(状態)

ほとんどの k8s オブジェクトはオブジェクトの設定を管理する 2 つの入れ子になったオブジェクトのフィールドを持っている (spec, status)
spec を持っているオブジェクトは作成時に spec を設定する必要があり、望ましい状態としてオブジェクトに持たせたい特徴を記述する必要がある
status オブジェクトは、オブジェクトの現在の状態を示し、k8s のコントロールプレーンは望ましい状態と status が一致するように管理をする

- 必須フィールド
  - apiVersion
  - kind: どの種類のオブジェクトを作成するのか
  - metadata: オブジェクトを一意に特定するための情報
  - spec: 望ましい状態

---

# Kubernetes オブジェクト管理

### 管理手法

- 命令型コマンド
  - 現行のオブジェクトを対象にし、開発用プロジェクトで利用される
- 命令型オブジェクト設定
  - 個々のファイルを対象にし、本番用で使われる
- 宣言型オブジェクト設定
  - ファイルのディレクトリを対象にし、本番用で使われる

---

# オブジェクトの名前と ID

クラスター内のオブジェクトにはそのタイプのリソースに固有の名前があり、クラスター全体で一位の UID もある。
同じ名前空間内に myapp-1234 という名前の Pod は 1 つしか含められないが、myappp-1234 という名前の 1 つの Pod と 1 つの Deployment を含めることができる。
一意でない属性の付与のためにはラベルとアノテーションがある

## 名前

クライアントから提供され、オブジェクトを参照する文字列 (ex. /api/v1/pods/<名前>)
同じ種類のオブジェクトでは同じ名前を同時には持てないが、削除すればできる
以下３つはよく使われる命名規則

- DNS サブドメイン名
- DNS ラベル名 => ドメイン名の . で区切られた部分のこと
- パスセグメント名

## UID

オブジェクトを一意に識別するための k8s が生成する文字列 k8s クラスターの生存期間中にわたって生成されたすべてのオブジェクトは異なる UID を持っている

---

# ラベルとセレクター

ラベルはオブジェクトに割り当てられるキーとバリューのペア
ラベルはオブジェクトをグルーピングするために使うことができ、いつでも追加修正が可能

## ラベルセレクター

ラベルセレクターを介して、クライアントとユーザーはオブジェクトのセットを指定可能。
k8s API がサポートするセレクターは等価ベースと集合ベース

- 等価ベース
  - =,==,!=
- 集合ベース
  - in, notin, exists

---

# 名前空間

k8s は同一の物理クラスター上で複数の仮想クラスターの動作をサポートするが、この仮想クラスターを NameSpace と呼ぶ

## 複数の NS を使うとき

複数のチーム、プロジェクトにまたがる多くのユーザーがいる環境での試用を目的としている。
数人から数十人のクラスターに対して NS を作成する必要はない
同じアプリケーションの異なるバージョンなど、少し違うリソースをただ分割するだけに複数の NS を使う必要はない。
=> この場合は NS 内でリソースを区別するためにラベルを使う

## NS を利用する

`kube get namespace` によってクラスター内の NS の一覧を表示できる
k8s の起動時には 4 つの初期 NS が作成されている

- default: 他に NS を持っていないオブジェクトのためのデフォルト NS
- kube-system: k8s システムによって作成されたオブジェクトのための NS
- kube-public: すべてのユーザーから読み取り可能
- kube-node-lease: クラスターのスケールに応じたノードハートビートのパフォーマンスを向上させる各ノードに関連した Lease オブジェクトのための NS
- NS の設定
  `kubectl run nginx --image=nginx --namespace=<insert-namespace-name-here>`

## すべてのオブジェクトが NS に属しているとは限らない

Node や PersistentVolume のような低レベルのリソースはどの NS にも属さない

```
# NS に属しているものを確認するコマンド
kubectl api-resources --namespaced=true
```

---

# アノテーション

ユーザーは識別用途でない任意のメタデータをオブジェクトに割り当てるためにアノテーションを使用できる
アノテーションはラベルと同様にキーバリューのマップとなる
下記はアノテーションの利用例

- ビルド、リリースやタイムスタンプのようなイメージの情報
- ロギング、管理分析用のポインタ
- デバッグ目的で使用されるためのクライアントライブラリやツールの情報

---

# フィールドセレクター

１つ以上のリソースフィールドの値を元に k8s リソースを選択するためのもの。
status.phase が running の Pod をすべて選択している例: kubectl get pods --field-selector status.phase=Running

---

# ファイナライザー

削除対象としてマークされたリソースを削除する前に特定の条件が満たされる魔 dk8s を待機させるための名前空間付きキー
Pod 削除時に PersistentVolume を開放する必要があり、ファイナライザーが PV の解放を担当し、解放が完了するまで Pod は削除されない
=> 整合性を担保している

## どのようにファイナライザーは動作するか

マニフェストファイルを使ってリソースを作るときに metadata.finalizers フィールドで指定できる

---

# オーナーと従属

いくつかのオブジェクトは他のオブジェクトのオーナーになっている。
例えば ReplicaSet は Pod の集合のオーナー

## オーナーリファレンス

従属オブジェクトはオーナーオブジェクトを参照するためのフィールドを持っている。
従属オブジェクトはオーナーオブジェクトが削除されたときにガベージコレクションをブロックするかどうかを管理する ownerReference.blockOwnerDeletion フィールドも持っている

---

# 推奨ラベル

共通のラベルを使うことで、様々なツールに対応できるようになるというもの
例としては、app.kubernetes.io/name や app.kubernetes.io/instance などがある。

---

# ノード

ノード上で実行される Pod にコンテナを配置してワークロードの実行をする。
ノードは 1 つの VM または物理的なマシン
1 つのノード上のコンポーネントには kubelet, コンテナランタイム、kube-proxy が含まれる (すべてのノードに？)

## 管理

ノードを API サーバーに加えるには２つの方法がある (クラスターに加えるということ？)

1. ノード上の kubelet がコントロールプレーンに自己登録する

- kubelet のフラグ --register-node が true のとき、自身を登録しようとする。これは推奨されているパターン

2. ユーザーが手動で Node オブジェクトを追加

- 上記フラグを false にする。

## ノードのステータス

- Address
  - HostName,ExternalIP,InternalIP などがある
- Conditions
  - Ready: ノードの状態が有効で Pod を配置可能な場合に True になる
  - DiskPressure: ディスク容量が圧迫されているときに True になる
  - PIDPressure: プロセスが圧迫されているときに True になる
- Capacity と Allocatable
- Info: カーネルや k8s,Docker のバージョンなど

## ノードのハートビート

ハートビートは k8s ノードから送信され、ノードが利用可能化判断するのに役立つ

1. Node の .status 更新
2. Lease object?

## ノードコントローラー

ノードの存続期間中に下記役割を果たす

1. ノードが登録されたときに CIDR ブロックをノードに割り当てる
2. ノードコントローラーの内部ノードリストをクラウドの利用可能なマシンと一致させる
3. ノードの状態を監視

# ノードとコントロールプレーン間の通信

信頼できないネットワーク上でクラスターが実行できるようにしている。

## ノードからコントロールプレーンへの通信

ノードからのすべての API は API サーバーで終了し、コントロールプレーンコンポーネントはどれもリモートサービスを公開するようにはなっていない。
API サーバーは 1 つ以上の形式のクライアント認証が有効になっている状態で、セキュアな HTTPS ポートでリモート接続をリッスンするように設定されている
ノードは、有効なクライアント認証情報とともに、API サーバーに安全に接続できるように、クラスターのパブリックルート証明書でプロビジョニングされる必要がある
これらにより、ノード上で動作する Pod からコントロールプレーンへの接続はデフォルトでセキュアで、信頼されていないネットワークやパブリックネットワークを介して実行可能

## コントロールプレーンからノードへの通信

2 つの経路がある

1. API サーバーからクラスター内の各ノードで実行される kubelet プロセスへの通信経路

- Pod のログの取得、実行中の Pod へのアタッチ、kubelet のポート転送機能の提供に使われる
- kubelet の HTTPS エンドポイントで終了する接続だが、デフォルトでは kubelet サービング証明書を検証しないので、信頼できないネットワークを解するのは安全じゃない
- よって、サービング証明書を検証するか、SSH トンネルを使うなどする (SSH トンネルは現在は非推奨で、Konnectivity を使うべし)

2. API サーバーのプロキシ機能を介した API サーバーから任意のノード、Pod、サービスへの通信経路

- デフォルトで HTTP なので、認証も暗号化もされない。
  => 何に使う？

## konnectivity サービス

SSH トンネルの代替として、コントロールプレーンからクラスターへの通信に TCP レベルのプロキシを提供
