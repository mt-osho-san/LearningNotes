# 1 章　ブラウザは何をしているのか

- 基本的な HTTP のリクエスト、レスポンス内容についての解説をしている
- HSTS のデータベースがあることを知らなかった
  - HSTS 自体は http ヘッダに Strict-Transport-Security の項目を定義することで次回以降 https での通信をさせる
    - 初回は平文での通信になってしまう
  - HSTS のデータベース（リスト）というのは、正式には HSTS Preload というもので、そのリストに該当するページは初回アクセス時から https での接続をさせる仕組み
    - 主要ブラウザはほぼ対応している

---

# 2 　章　

- この章では HTTP/1.0 ができるまでの歴史と、HTTP/1.0 におけるメソッドやパスなどについて解説をしている
- HTTP/0.9 という名前ができたのは、HTTP/1.0 ができてからだったのか
- MDN はもともと Mozilla のものだったが、現在は Google や MS もコントリビュートしている
- HTTP/0.9 では、HTML 以外を送る想定がなかったり、新しい文書に更新したり、削除したりできなかった
- http ヘッダーの"x-"は私的な独自ヘッダーに利用しているが、「標準外のフィールドが標準になったときに不便が発生するため、2012 年 6 月の RFC 6648 で非推奨になりました」らしい
- メールとニュースグループは HTTP の祖先のようなもので、それぞれ MIME やフィールド、メソッドやステータスコードが受け継がれている
- canon が.canon のトップレベルドメインを持っているのか、canon は IT のイメージあまりなかったが当時は進んでいたのか？（google で canon 調べると canon.co.jp だった）
- キリル文字の і とローマ字の i など似た文字を使った攻撃をホモグラフ攻撃というらしい、名前あったのか
- dk 社もスパルタン仕様

---

# 3 章

- HTTP/1.0 の主にブラウザ側での動きを解説する。
- フォームの機能を使ってファイル送信を-d のかわりに-F とすることで実現可能
- サーバーからブラウザへの通信時の gzip などの圧縮はサーバー側で設定が必要？
  - もしくは特に設定せずとも圧縮している？
- セッションクッキーと永続クッキーの 2 つがあることを知らなかった
  - 永続クッキーはいつまで残るのか
  - ＝＞"Cookie に期限日が含まれていない場合は、セッション Cookie と見なされます"
  - デフォルトはセッションクッキーということか
- クッキーはリクエスト時に毎回付与されるので適切なサイズ、量のクッキーを使うことが通信容量の観点で良い
- localStorage, sessionStorage は同一オリジンでのみ利用可能なのですね。
- ベーシック、ダイジェスト認証のデメリット
  - リクエストごとに認証が必要、明示的なログオフができない、端末の識別ができない
- 代わりにフォームのログインとクッキーを使ったセッション管理を利用するケースがほとんど
  - ダイジェスト認証とは違い、ID、PASS を直接サーバーに送信するので SSL/TLS が必須
- 署名付きクッキーでデータの一時的な保存
  - サーバー側にデータ保存のしくみが必要ないが、クライアントが別々のデバイスから利用したら共有されない
  - 安易に使うとユーザビリティが悪くなりそう
- なにかの勉強で x-forwarded-for ヘッダの話があった気がするが、Forwarded で標準化されているのか
- Last Modified（更新日時によるキャッシュ）はキャッシュの利用を確認するためにもサーバーへのアクセスが必要なので、Expired が導入された
  - 地球の裏側だとキャッシュの確認だけで 0.2 秒、光の速度を感じる
- Cache control の max-age, private などでキャッシュを利用するかどうかを制御可能（HTTP/1.1~）
- Vary ヘッダーの存在は聞いたことがなかった
  - ユーザーやデバイスによって表示内容が変化する際の理由を示している
- Referer スペルミスなのか笑（Referrer が英語としては正しい）
- Referer でアクセス元の URL がわかるので、機密情報を GET パラメータにいれるのは良くない
- robots.txt のほうが優先されるが、meta タグのほうが細かい調整が可能（noindex, nofollow など）
  - robots.txt を知っていて設定しない場合はクロールされても何も言えない
- サイトマップ：ウェブサイトに含まれるページ一覧とそのメタデータを提供する XML ファイル
  - サイトマップって聞いたことあったがしらなかった
- Google のガイドライン「同一コンテンツをすべてのブラウザに配信し、必要な設定を選ばせるレスポンシブデザインが推奨」
  - user-agent で表示内容を変えるもんかと思っていたが、推奨ではないということか

# 4 章

- HTTP/1.1 以降の機能について紹介
- 主な変更点として、通信の高速化、TLS による暗号通信、新メソッド追加など
- 以前は毎回コネクションを張るためにハンドシェイクをしていたが、keep-alive はこれを削減することで、通信速度の向上
  - ブラウザの同時接続数の推奨値が 4 => 2 に下がるというのはどういうこと？
  - ブラウザ１つに対して４つくらい接続していないと通信が遅いということ？
  - 接続を切るにはヘッダに Connection: Close を付与するか、タイム・アウトするか
  - 持続時間はクライアント、サーバー両方もっており、Frefox115s, nginx75s, apache15s
- パイプライニングはレスポンスを待たずにリクエストを送るというものだが、対応していないサーバーが多かったり、レスポンスの順序が大事なのっで HoLB が発生したりで、使われることはほとんどなくなった
  - が、HTTP/2 でストリームという機能として生まれ変わった（@ 8 章）
- アルゴリズムを秘密にするのではなく、アルゴリズムを公開しても暗号化ができることが大事
- TLS は接続の確立時に公開鍵暗号を使って共通鍵を作る。それ以降は共通鍵で通信をすることで安全性とスピードの両立
- 最も長い場合の TLS 接続にかかる RTT
  - TCP で 1.5, TLS ハンドシェイクで 2RTT, HTTP のリクエストで 1RTT => 計 4RTT (TCP の最後と TLS の最初は一緒にできる)
  - この往復を減らすために keep-alive やセッション再開機能、PSK などがある
- 鍵交換の方法、暗号化、署名方式などをまとめて暗号スイートという
- TLS はサーバークライアント間が信頼できない通信路でも安全、一方でブラウザ上のクラッキングなどは対処できない
- サーバー経由でクライアント同士がチャットする仕組みもがあるのか（この場合はサーバーの中は秘匿されない）
  - どういうアプリで使うのか
- ACME プロトコル初めて聞いた（自動証明書管理環境）
  - Let's Encrypt の無料の証明書サービスで利用されている
- 証明書の種類の話セキスペであったなあ
  - 今はもうブラウザ上での表示がかわることはないのか（TLS かどうかしか気にしない）
- 1.1 では PUT と DELETE, Options, trace, connect, path が追加された
  - Options は利用可能なメソッドを返す、が多くのサーバーでは有効にされていない
  - connect は HTTP のプロトコル上に他のプロトコルのパケットを流せる（主に HTTPS を中継する目的で使われる）
- アップグレードは、HTTP から別のプロトコルへアップグレードできる機能
  - HTTP ＝＞ TLS、Websocket、HTTP2 へ
  - 現在はそもそも TLS 前提なので HTTP2 では削除されている機能
- チャンクはデータを一括で送るのではなく、小分けにして行う。
  - 生成 AI で使われる＝＞ WebSocket だと思っていた
- データ URI スキームでは、URI がデータそのものになる
  -
